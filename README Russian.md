# Основные правила и принципы написания CSS

Большие, долгоживущие проекты с большим количеством разработчиков требуют от нас выполнять нашу работу определённым образом для достижения следующих целей:

* Легко поддерживаемые файлы стилей
* Прозрачность и читаемость кода
* Масштабируемость стилей

Несколько техник помогут нам достичь этих целей.

Первая часть этого документа расскажет про синтаксис, форматирование и анатомию CSS, вторая часть раскроет темы методов, способа мышления и отношения к написанию и созданию CSS архитектуры. Звучит многообещающе?

## Оглавление

* [Анатомия CSS-документа](#анатомия-css-документа)
  * [Общие моменты](#общие-моменты)
  * [Один файл или много файлов](#один-файл-или-много-файлов)
  * [Оглавление](#оглавление)
  * [Названия секций](#названия-секций)
* [Организация правил](#организация-правил)
* [Анатомия CSS-правила](#анатомия-css-правила)
* [Соглашения об именовании](#соглашения-об-именовании)
  * [JS-классы](#js-классы)
  * [Интернационализация](#интернационализация)
* [Комментарии](#комментарии)
  * [Комментарии на стероидах](#комментарии-на-стероидах)
    * [Квази-селекторы](#квази-селекторы)
    * [Теги в коде](#теги-в-коде)
    * [Ссылки между объектом и его расширением](#ссылки-между-объектом-и-его-расширением)
* [Напиcание CSS](#напиcание-css)
* [Создание новых компонентов](#создание-новых-компонентов)
* [OOCSS](#oocss)
* [Разметка](#разметка)
* [Единицы измерения](#единицы-измерения)
  * [Размер текста](#размер-текста)
* [Cокращённая запись](#сокращённая-запись)
* [Идентификаторы](#идентификаторы)
* [Селекторы](#селекторы)
  * [Перенасыщенные селекторы](#перенасыщенные-селекторы)
  * [Производительность селекторов](#производительность-селекторов)
* [Последовательность CSS-селекторов](#последовательность-css-селекторов)
* [`!important`](#important)
* [Магические числа и абсолютные значения](#магические-числа-и-абсолютные значения)
* [Стили в условных комментариях](#стили-в-условных-комментариях)
* [Отладка](#отладка)
* [Препроцессоры](#Препроцессоры)

---

## Анатомия CSS-документа

Мы всегда должны стараться соблюдать принятое форматирование. Это означает согласованные комментарии, синтаксис и соглашение об именовании.

### Общие моменты

Ограничьте строки 80 символами, где это только возможно. Исключениями могут быть синтаксис градиентов и ссылки в комментариях. Это нормально, мы ничего не можем с этим сделать.

Я предпочитаю отступы в четыре пробела и писать многострочный CSS.

### Один файл или много файлов

Некоторые предпочитают работать с одиночными, большими файлами. Это хорошо и при следовании данному руководству у вас не прибавится проблем. Начав использовать Sass, я начал разбивать мои стили на множество маленьких, подключаемых через `include`. Это тоже хорошо… Как бы там ни было, правила и рекомендации, приведённые ниже, применимы к обоим способам. Единственное замечание относится к «Оглавлению» и «Названиям секций». Продолжайте читать, чтобы узнать подробности.

### Оглавление

В начале CSS файла я храню таблицу содержимого, которая уточняет какие секции содержатся в этом файле, например:

    /*------------------------------------*\
        $CONTENTS
    \*------------------------------------*/
    /**
     * CONTENTS............You’re reading it!
     * RESET...............Set our reset defaults
     * FONT-FACE...........Import brand font files
     */

Оглавление подскажет следующему разработчику, что ему можно ожидать в этом файле. Каждый пункт оглавления совпадает с названием секции.

Если вы работаете с одним большим файлом стилей, то секция, попавшая в оглавление, также должна находиться в этом файле. Если вы работаете со стилями, разнесёнными в несколько файлов, то каждый пункт оглавления привязан к команде подключения файла с этой секцией.

### Названия секций

Оглавление будет бесполезно пока не будет соотноситься с названиями секций. Оформляйте секцию таким способом:

    /*------------------------------------*\
        $RESET
    \*------------------------------------*/

Знак `$` префиксно дополняет название секции, позволяя искать по файлу такой шаблон `$[НАЗВАНИЕ-СЕКЦИИ]` и, таким образом, **производить поиск только по названиям секций**.

Работая с большим файлом стилей, оставляейте отступ в пять строк между секциями, вот так:

    /*------------------------------------*\
        $RESET
    \*------------------------------------*/
    [Our
    reset
    styles]
     
     
     
     
     
    /*------------------------------------*\
        $FONT-FACE
    \*------------------------------------*/

Этот участок пустого пространство легко и быстро бросается в глаза при пролистывании большого файла.

При работе с несколькими, подключаемыми файлами стилей, начинайте каждый файл с названия секции и в этом случае нет необходимости в пустых строках.

## Организация правил

Возьмите за правило писать стили в порядке специфичности. Это обеспечит гарантию того, что вы используете все преимущества вложенности и каскада.

Порядок правильно организованного файла стилей похож на это:

1. **Reset** – сброс, платформа для написания кода стилей.
2. **Элементы** – `h1`, `ul` и подобные без указания классов.
3. **Объекты и абстракции** — общие конструкции без дизайна.
4. **Компоненты** – компоненты, построенные на объектах и их расширениях.
5. **Полезные стили** – состояния ошибок и другое.

Такая структура означает, что каждая секция, написанная ниже, строится и наследует правила, описанные в предыдущих. Это приведёт к меньшему количеству проблем специфичности и отменяющих переопределений, а также к более качественной CSS архитектуре.

Для дальнейшего чтения по этой теме, я не могу отозваться о книге [SMACSS](http://smacss.com) от Джонатана Снука настолько хорошо, насколько она того заслуживает.

## Анатомия CSS-правила

    [Селектор] {
        [Свойство]:[Значение]
        [<-   Объявление  ->]
    }    

Я руководствуюсь несколькими правилами при написании CSS-правил.

* Дефис как разделитель (Исключая БЭМ запись,
  [смотрите ниже](#cоглашения-об-именовании))
* Отступ в 4 пробела
* Многострочность
* Свойства сортируются в порядке релевантности (НЕ в алфавитном)
* Выравнивайте свойства с вендорными префиксами так, чтобы их значения были друг под другом.
* Используйте отступы в стилях, чтобы отразить структуру HTML.
* Всегда заканчивайте объявление знаком точки с запятой

И сразу пример:

    .widget{
        padding:10px;
        border:1px solid #BADA55;
        background-color:#C0FFEE;
        -webkit-border-radius:4px;
           -moz-border-radius:4px;
                border-radius:4px;
    }
        .widget-heading{
            font-size:1.5rem;
            line-height:1;
            font-weight:bold;
            color:#BADA55;
            margin-right:-10px;
            margin-left: -10px;
            padding:0.25em;
        }

Наглядно видно, что `.widget-heading` является дочерним элементом `.widget`, так как `.widget-heading` имеет дополнительный отступ относительно селектора `.widget`. Эту полезную информацию разработчики могут считать просто взглянув на отступы в наших стилях.

Также мы видим, что объявления селектора `.widget-heading` отсортированы в порядке релевантности; `.widget-heading` вероятнее всего текстовый элемент, поэтому мы начинаем правило с типографских свойств, за которыми уже следуют все остальные.

Единственное исключение в многострочном CSS может быть в таком случае:

    .t10    { width:10% }
    .t20    { width:20% }
    .t25    { width:25% }       /* 1/4 */
    .t30    { width:30% }
    .t33    { width:33.333% }   /* 1/3 */
    .t40    { width:40% }
    .t50    { width:50% }       /* 1/2 */
    .t60    { width:60% }
    .t66    { width:66.666% }   /* 2/3 */
    .t70    { width:70% }
    .t75    { width:75% }       /* 3/4*/
    .t80    { width:80% }
    .t90    { width:90% }

В этом примере (из [сеточной системы inuit.css](https://github.com/csswizardry/inuit.css/blob/master/inuit.css/partials/base/_tables.scss#L88))
гораздо больше смысла использовать однострочные правила.

## Соглашения об именовании

В большинстве случаев я использую дефис как разделитель слов в классах (например `.foo-bar`, не `.foo_bar` и не `.fooBar`), но в некоторых случаях я использую БЭМ-запись.

<abbr title="Блок, Элемент, Модификатор">БЭМ</abbr> — методология именования и категоризации CSS селекторов для приведения их в чёткий порядок, придания прозрачности и информативности.

Соглашение об именовании выражается следующим шаблоном:

    .block{}
    .block__element{}
    .block--modifier{}

* `.block` представляет собой наивысший уровень абстракции или компонента.
* `.block__element` является вложенным элементом `.block`, формирующим `.block` как сущность.
* `.block--modifier` — класс отражающий другое состояние или версию `.block`.

**Аналогия**, иллюстрирующая работу БЭМ, может быть такой:

    .person{}
    .person--woman{}
        .person__hand{}
        .person__hand--left{}
        .person__hand--right{}

В этом примере приведен базовый объект описывающий человека, и существует отличный от базового тип человека — женщина. Также наглядно видно, что у людей есть руки; они являются частями человека, и рука может быть как левой, так и правой.

Теперь мы можем создавать селекторы, опираясь на базовые объекты и также без проблем понимаем, что делает каждый конкретный селектор; является ли он частью компонента (`__`) или же модификацией (`--`)?

Итак, `.page-wrapper` является отдельным селектором; он не формирует часть компонента и, значит, является валидным селектором. В противовес этому, селектор `.widget-heading` относится к компоненту; он является дочерним элементом `.widget` и поэтому мы вынуждены переименовать этот класс в `.widget__heading`.

БЭМ непригляднее и перегруженней, но, тем не менее, он предоставляет огромные возможности, с помощью которых мы можем определить назначение и отношения элементов просто посмотрев на их классы. Также, БЭМ обычно сжимается c помощью gzip, после использования минификаторов, которые первоклассно работают с повторениями.

Независимо от того, используете вы БЭМ или нет, всегда заботьтесь о грамотном именовании классов; классы должны быть короткими, насколько это возможно, но настолько длинными, насколько это необходимо. Убедитесь, что абстракции имеют очень общие классы (например `.ui-list`, `.media`) для возможного переиспользования. Расширения абстракций должны иметь гораздо более конкретные классы (например `.user-avatar-link`). Не беспокойтесь о длинных классах; gzip выполнит свою работу потрясающе хорошо.

### Классы в HTML

Для большей читаемости разделяйте классы в разметке двумя (2) пробелами:

    <div class="foo--bar  bar__baz">

Увеличенные отступы между классами позволяют легко вычленять отдельные классы.

### Джаваскрипт классы

**Никогда не используйте обычные CSS классы для привязывания JavaScript логики.** Связывание логики скриптов с оформлением ведёт к тому, что мы не сможем использовать одно без другого.

Если вам требуется привязать к вёрстке какую-то логику используйте специальный JS класс — обычный класс, дополненный префиксом `.js-`, например `.js-toggle`, `.js-drag-and-drop`. Данный приём позволяет добавлять JS и CSS классы, без создания самому себе проблем в будущем, а также разделяет логику поведедения и оформление страницы друг от друга.

    <th class="is-sortable  js-is-sortable">
    </th>

Приведенная в пример разметка имеет два класса; один предназначен для оформления сортируемых табличных колонок и другой для того, чтобы вы могли добавить возможность сортировки.

## Комментарии

Я использую комментарии в стиле docBlock, которые я ограничиваю в 80 символов:

    /**
     * Пример комментария в стиле docBlock
     *
     * Более длинное описание комментария, описывающего код в больших
     * подробностях. Комментарии ограничиваются в 80 символов.
     * 
     * Можно вставлять разметку в комментарии. Делается это так:
     * 
       <div class=foo>
           <p>Lorem</p>
       </div>
     * 
     * Разметка префиксно не дополняется звездочками, чтобы оставить возможность
     * легкого копипаста.
     * 
     */

Вы должны документировать и комментирвоать так много, насколько вы можете это делать; всё, что кажется вам прозрачным и само-объясняемым может не быть таковым для другого разработчика. Пишите кусок кода и сразу после этого объясняйте его.

### Комментарии на стероидах

Существуют несколько продвинутых техник, связанных с комментариями:

* Квази-селекторы
* Теги в коде
* Ссылка на расширяемый компонент

#### Квази-селекторы

Вы никогда не должны перегружать селектор; скажем так, вы никогда не должны писать `ul.nav{}`, если вы можете написать просто `.nav{}`. Перегрузка селекторов приводит к уменьшению производительности селекторов (увеличению времени рендеринга страницы), исключает возможность потенциального переиспользования селектора для элемента другого типа и увеличивает специфичность селектора. Это все те вещи, которые должны избегаться при любых условиях.

Иногда бывает полезно сообщить следующему разработчику, в каком контексте вы предполагаете должен использовать селектор. Давайте рассмотрим `.product-page`; Этот класс выглядит так, как будто должен использоваться на корневых контейнерах, таких как `html` и `body`, но селектор `.product-page` не имеет возможности сказать на какой именно контейнер он был использован.

Используя смешанные селекторы (например, комментирование первого простого селектора по типу), мы можем сообщить на какой контейнер следует использовать этот класс:

    /*html*/.product-page{}

В этом примере мы чётко видим на какой элемент применён данный класс, без проблем со специфичносью и переиспользованием этого кода;

Другие примеры могут быть такими:

    /*ol*/.breadcrumb{}
    /*p*/.intro{}
    /*ul*/.image-thumbs{}


Мы можем увидеть к какому типу элемента применён класс и также недопустили увеличения специфичности селектора.

#### Теги в коде

При написаниии нового компонента, оставляйте теги основнные на функиональности компонента:

    /**
     * ^navigation ^lists
     */
    .nav{}
    
    /**
     * ^grids ^lists ^tables
     */
    .matrix{}

Теги позволяют разаработчикам находить сниппеты поиском по названию тега. Если 
разработчику понадобится поработать со списками, он может начать искать `^color` и найдёт объекты `.nav` и `.matrix`

#### Ссылки между компонентом и его расширением

Используя методы OOCSS, вы часто будете иметь два участка кода (один — скелет приложения и второй — темизация) и при этом расширение сильно связано с классом-родителем; но часто бывает так, что они находятся в разных файлах. Для установления чёткой связи между объектом и его расширением мы применяем <i>ссылки между компонентом и его расширением</i>. Данные ссылки являются просто комментариями.

В вашей основном файле стилей:

Эти теги позволят другим разработчикам искать код, используя сниппеты как этот:

    /**
     * Extend `.foo` in theme.css
     * (Дополнен классом `.foo` в theme.css)
     */
     .foo {}

In your theme stylesheet:

    /**
     * Extends `.foo` in base.css
     * (Дополняет класс `.foo` из base.css)
     */
     .bar{}

Тем самым мы получили устойчивую связь между двумя связаными логически, но физически разбитыми на части кусками кода.

---

## Напиcание CSS

Предыдущая часть рассказывает какую соблюдать структуру и как писать наш CSS.

Предыдущая часть рассказывает как структурировать и формировать наш CSS; здесь существуют более-менее чёткие правила. Следущая глава будет немного более теоретической и повествует про способ мышления и подход.

## Создание новых компонентов

При создании нового компонента пишите разметку **до того**, как напишите хоть одну строчку CSS. Это позволяет увидеть какие свойства наследовались и избежать повторного применения избыточных стилей.

Если вы будете писать сначала разметку, то вы сможете сфокусироваться на информации, контенте и семантике и **только после** этого применить необходимые стили.

## OOCSS

Я использую OOCSS подход; Я разделяю компоненты на структуру (объекты) и оформления (расширения). Как **аналогия** (не пример) можно рассмотреть следующий сниппет:

    .room{}
    
    .room--kitchen{}
    .room--bedroom{}
    .room--bathroom{}

Мы располагаем комнатами нескольких типов, но все комнаты имеют похожие свойства; В каждой комнате есть пол, потолок, стены и двери. Мы можем обобщить эту информацию в общем классе `.room{}`. Тем не менее у нас есть специальные отличающиеся друг от друга типы комнат; Кухня должна иметь плитку на полу, спальня — ковёр; В ванной не должно быть окна, а в спальне, напротив, должно. В каждой комнате скорее всего стены покрашены в свой цвет. OOCSS учит нас абстрагироть похожие свойства в базовый объект и в дальнейшем дополнять его с помощью расширяющих классов для добавления особенных качеств.

Вместо того, чтобы плодить множество уникальных компонентов, попытайтесь распознать повторяющиеся шаблоны дизайна и создать из них абстракции; cверстайте эти абстракции, а затем используйте уточняющие классы для расширения их внешнего оформления.

Если вы вынуждены создать новый компонент, то разделите его на структуру и декоративное оформление; сверстайте структуру используя общие классы, тем самым давая возможность использования структуры компонента в других местах вашего проекта, и затем, используя более специфичные классы, оформите компонент в соответствии с требованиями дизайна.

## Разметка

Все компоненты должны быть полностью независимы от ширины; ваши компоненты должны оставаться резиновыми и их ширина должна контролироваться системой модульных сеток.

Высота **никогда** не должна назначаться элементам. Высота применяется только на сущности, имевшие размеры *до того*, как попали на сайт (например, картинки и спрайты). Никогда не устанавливайте высоту на `p`, `ul`, `div`, вообще что угодно. Вы можете добить желаемого эффекта с помощью гораздо более гибкого `line-height`.

Систему модульных сеток следует рассматривать, как структуру сайта. Вы создаёте структуру сайта, а затем наполняете её информацией. Отделяя систему модульных сеток от созданных нами компонентов, вы можете менять расположение компонентов на сайте намного проще, если бы ширина и высота были бы установлены прямо на компоненты; это делает наш фронтэнд более гибким и быстрым в работе.

Вы никогда не должны применять никаких стилей на ячейку сетки, так как они лслужат только целям разметки. Применяйте стили только на *содержание ячейки*. Никогда, *ни при каких обстоятельствах* не применяйте свойства меняющие поведение `box-model` к ячейкам сетки.

## Единицы измерения

Мы используем различные методы для задания размеров интерфейса: проценты, пиксели, `ems`, `rems` или вообще не задаем единицы измерения.

Ячейки сетки в идеале должны иметь размеры в процентах. Используя сетку для управления колонками на страницах, я оставляю компоненты полностью свободными от размеров (как я рассказывал ранее).

Размеры шрифтов я устанавливаю в `rem` c запасным решением с использованием пикселей. Этот метод предоставляет доступность контента как с `em` и уверенность при использовании пикселей. 
Простой Sass миксин для одновременной работы с пикселями и `rem` (вы должны определить переменную `$base-font-size` ранее в стилях):

    @mixin font-size($font-size){
        font-size:$font-size +px;
        font-size:$font-size / $base-font-size +rem;
    }

Я использую пиксели только для элементов, имеющих размеры и вне контекста сайта — в основном, это картинки и спрайты.

### Типографские единицы измерения

Я составил список классов (похожих на модульную сетку) для задания размера текста. Эти классы могут быть использованы стилизации текста в двухцепочечной иерархии. Моя статья «[Pragmatic, practical font-sizing in CSS](http://csswizardry.com/2012/02/pragmatic-practical-font-sizing-in-css)» расскажет вам, как это работает.

## Cокращенная запись

**Сокращенную запись следует с осторожностью.**

Это может показаться заманчивым использовать правила похожие на `background: red;` но делая это, мы на самом деле говорим: «Я хочу, чтобы фоном была не одна картинка скролящуюся, спозиционированную вверх и влево и повторяющуюся по X и Y и чтобы цвет фона был красный». В девяти случаях из десяти это не высовет никаких проблем, но в 10% обязательно доставит достаточно неприятностей, чтобы не использовать сокращенные записи. Вместо этого используйте `background-color: red;`.

Например, ситуация с правилом `margin: 0;` — оно ясное и короткое, но черезчур **специфичное**. Если вы на самом деле хотите сделать отступ снизу от элемента, то гораздо более подходящим будет использовать `margin-bottom: 0;`.

Старайтесь сохранять чёткое представление о свойствах, которые вы устанавливаете и следите за тем, чтобы случайно не сбросить свойства других элементов, используя сокращенную запись. Например, если вы хотите сбросить нижний отступ, то нет никакой необходимости в агрессивном сбрасывании всех отступов с помощью `margin: 0;`.

Сокращённая запись сама по себе хороша, но легко используется неправильно.

## Идентификаторы

A quick note on IDs in CSS before we dive into selectors in general.

**NEVER use IDs in CSS.**

They can be used in your markup for JS and fragment identifiers but use only
classes for styling. You don’t want to see a single ID in any stylesheets!

Classes come with the benefit of being reusable (even if we don’t want to, we
can) and they have a nice, low specificity. Specificity is one of the quickest
ways to run into difficulties in projects and keeping it low at all times is
imperative. An ID is **255** times more specific than a class, so never ever use
them in CSS _ever_.

## Cелекторы

Сохраняйте селекторы эффективными, рациональными и переносимыми.

Тяжелые, глубоко вложенные селекторы никуда не годятся по ряду причин. Например возьмем `.sidebar h3 span {}`. Этот селектор основан на вложении и поэтому нет возможности переместить `span` из `h3` и из `.sidebar` — следовательно, нет возможности обеспечить поддержку стилей на должном уровне.

Слишком длинные селекторы также вызывают проблемы производительности; чем больше проверок в селекторе (например селекторе `.sidebar h3 span` имеет три проверки, а `.content ul p a` — четыре), тем больше работы выполняет браузер.

Старайтесь следить, чтобы ваши стили не зависели от вложенности, где это только возможно, а также что ваши селекторы были короткими и легко воспринимаемыеми.

Селекторы сами по себе должны быть короткими (например, состоящим из одного простого селектора), но имена классов должны быть такими длинными, насколько это требуется. Класс `.user-avatar` приятнее и понятнее, чем `.usr-avt`.

**Запомните:** Классы на самом деле ни семантичны, ни не семантичны; Они применимы или нет! Перестаньте беспокоиться о «семантике» имён классов и выберите что-нибудь удобное в применении, с расчётом на дальнейшее использование.

### Перенасыщеные селекторы

Как говорилось выше, увидеть специфичный селектор — всегда плохой знак.

Перенасыщеный (гиперспецифичный) селектор это один из разряда `div.promo`. Скорее всего, мы можем достичь тот же самый эффект, используя лишь `.promo`. Конечно, иногда мы *хотим* определить класс в зависимости от элемента (например, если у вас есть общий класс `.error`, который должен выглядеть по разному на разных элементах (например, `.error { color: red; }` `div.error { padding: 14px; }`)), но по возможности избегайте этого, где это только возможно.

Другим примером слишком перенасыщенного селектора может быть `ul.nav li a {}`. Как описано выше мы сразу можем выкинуть `ul`, и так как мы знаем, что `.nav` это список, то ссылка будет вложена только в `li`, поэтому мы можем сократить `ul.nav li a {}` до `.nav a`.

### Производительность селекторов

Хоть это и правда, что браузеры только улучшают свои показатели в скорости рендеринга CSS, «Эффективность» — это то, на чём мы можем быть сфокусированы всегда. Короткие селекторы, неиспользование универсального (`* {}`) селектора и избегание больших комбинаций CSS3 селекторов должно помочь обойти проблемы производительности.

## Ключевой элемент селектора

Вместо использования селекторов спускающихся по всему DOM-дереву, чаще удобнее добавить требуемому элементу класс. Давайте рассмотрим конкретную ситуацию на примере `.header ul{}`…

Давайте представим, что `ul` действительно главная навигация на вашем сайте. Этот элемент находится в шапке сайта, как вы и ожидаете, и при этом не повторяется; `.header ul{}` будет работать, но это не идеальная и нерекомендуемая ситуация. Этот селектор недальновиден и недостаточно точен. Проблема станет очевидна так скоро, как вы добавите ещё один `ul` в шапку сайта — новый элемент унаследует на себя все стили нашего главного меню и шансы, что мы так и задумали весьма невелики. Это приведёт к вынужденному рефакторингу большого количества кода *или* отмене большинства стилей для второго `ul`, чтобы уничтожить последствия недостаточно специфичного селектора.

Ключевой элемент селектора должен отражать причину своего возникновения; спросите себя **«Я пишу этот селектор именно, потому что `ul` вложен в `.header` или из-за того, что этот элемент — это главное меню на моём сайте?»**. Ответ опреляет правильный селектор.

Всегда проверяйте, что ключевые элементы селектора не являются простыми селектороми тега или селекторами объекта/компонента/абстракции. Вы никогда не должны писать селекторы похожие на `.sidebar ul{}` или `.footer .media{}` в вашем файле стилей для темизации.

Будьте точны, конкретны; указывайте именно тот элемент, который вам нужен, не его родитель. Никогда не предполагайте, что разметка будет неизменной. **Пишите селекторы, указывающие на желаемые элементы, а не на те элементы, что уже оказались в разметке.**

Для полного объяснения прочитайте мою статью [Shoot to kill; CSS selector intent](http://csswizardry.com/2012/07/shoot-to-kill-css-selector-intent/)

## `!important`

Допустимо использовать `!important` только на вспомогательных классах. Превентивно добавлять `!important` удобно и полезно, например если вы знаете, что селектор `.error { color: red !important; }` всегда должен нуждаетсяв наибольшем приоритете.

Не приветствуется использование `!important` для исправления ошибок, например, чтобы помочь выбраться себе из ситуации с запутанной специфичностью. Переработайте ваш CSS и старайтесь избегать этих проблем рефакторингом ваших селекторов. Сохраняйте ваши селекторы короткими, откажитесь от ID — и ваша жизнь станет проще.

## Магические числа и абсолютные значения

Магическое число — число используемое лишь потому, что «это просто работает». Это порочная практика, так как очень редко она работает по какой-либо реальной причине и обычно достаточно недальновидна, негибка и причина самого числа вероятнее всего забудется. Магические числа устраняют симптомы, но не никак не влиют на проблему.

Например, использование правила `.dropdown-nav li:hover ul { top: 37px; }` для сдвига выпадающего пункта меню вниз при наведении на родителя `li` не принесёт ничего хорошего, так как 37px магическое число. 37px работает только потому, что в этом конретном сценарии (конкретный сайт в определённое время) меню оказалось высотой в 37px.

Вместо этого мы должны использовать `.dropdown-nav li:hover ul { top: 100%; }`, что означает без разницы какой высоты будет `dropdown-nav` меню, выпадающий пункт меню всегда будет сдвинут на 100% от верхней границы родителя.

Каждый раз, когда вы жестко задаёте число подумайте дважды; если вы можете избежать этого, используя ключевые слова или синонимы (например, `top: 100%` — сдвинуть на 100% от верха) или — даже лучше — не используя никаких элементов измерений, то вы должны избежать использования жестко заданного числа.

Каждое установленное вами числовое значение, скорее всего было необязательным.

## Conditional stylesheets

Использование файлов стилей по большому счёту можно избежать. Исключением может быть необходимость восполнить недостаточную поддержку (например, PNG с альфа–каналом в IE6).

Главное правило: вся разметка и `box-model` правила могут и *будут* работать без дополнительных файлов стилей, если вы отрефакторите ваш CSS. Это означает, что мы никогда не будем рады, если увидим `<!--[if IE 7]> element{ margin-left:-9px; } < ![endif]-->` или любой подобный CSS, используемый лишь для того, чтобы «заставить что-то работать правильно».

## Отладка

Если вы столкнулись с проблемой в CSS, то **удаляйте куски кода, до того как начать добавлять правила ещё** в попытке решить проблему. Проблема кроется в уже написанном CSS, написать ещё больше стилей — не самое верное решение!

Удаляйте куски разметки и стилей, пока проблема не исчезнет, затем определите в какую часть кода закралась проблема.

Это бывает достаточно удобно добавить `overflow: hidden;` на нужный элемент, чтобы избавиться от результатов кривой вёрстки, но `overflow` сам по себе никогда не был проблемой; **Исправляйте проблему, а не симптомы.**

## Препроцессоры

Sass — мой выбор среди препроцессоров. **Используйте его с умом** 
Используйте Sass, чтобы сделать ваш CSS более мощным, но избегайте вложенности, как чумы! Используйте вложенность только тогда, когда это действительно необходимо, например в «vanilla CSS»:

    .header{}
    .header .site-nav{}
    .header .site-nav li{}
    .header .site-nav li a{}

Что полностью избыточно в обычном CSS, следовательно следущий Sass код достаточно плох:

    .header{
        .site-nav{
            li{
                a{}
            }
        }
    }

Иcпользуя Sass пишите это так:

    .header{}
    .site-nav{
        li{}
        a{}
    }